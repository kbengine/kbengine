<html>
<head>
<title>Base - KBEngine base 文档</title>
<link href="../../style.css" rel="stylesheet" type="text/css">
</head>
<body>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><td align=left style="background:#0F5286"> <img src="../../logo.png"> </td></tr>
</table> <hr>
<h1>类 Base</h1>

<p style="text-align: center;"><span class="module_h1">[<a href="../Modules/KBEngine.html" class="module_h1">模块KBEngine</a>]</span></p><p>Base是<a href="../Modules/KBEngine.html">KBEngine</a>模块的一部分。 <a href="#detailed_description">更多...</a></p><p></p><pre>import KBEngine</pre>

<h2><a href="#" onClick="obj=document.getElementById( 'functions' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">成员函数</a></h2>
<table id="functions" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr><td>
<span class="function_list">def <a href="#addTimer" class="function_list" >addTimer</a>( self, initialOffset, repeatOffset=0, userArg=0 ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#createCellEntity" class="function_list" >createCellEntity</a>( self, cellEntityMB ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#createInNewSpace" class="function_list" >createInNewSpace</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#delTimer" class="function_list" >delTimer</a>( self, id ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#destroy" class="function_list" >destroy</a>( self, deleteFromDB, writeToDB ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#destroyCellEntity" class="function_list" >destroyCellEntity</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#teleport" class="function_list" >teleport</a>( self, baseEntityMB ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#writeToDB" class="function_list" >writeToDB</a>( self, callback, shouldAutoLoad ):</span>
</td></tr>

</table>

<h2><a href="#" onClick="obj=document.getElementById( 'callbacks' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">回调函数</a></h2>
<table id="callbacks" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr><td>
<span class="function_list">def <a href="#onCreateCellFailure" class="function_list" >onCreateCellFailure</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onDestroy" class="function_list" >onDestroy</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onGetCell" class="function_list" >onGetCell</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onLoseCell" class="function_list" >onLoseCell</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onPreArchive" class="function_list" >onPreArchive</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onRestore" class="function_list" >onRestore</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onTimer" class="function_list" >onTimer</a>( self, timerHandle, userData ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onWriteToDB" class="function_list" >onWriteToDB</a>( self, cellData ):</span>
</td></tr>

</table>

<h2><a href="#" onClick="obj=document.getElementById( 'attributes' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">属性</a></h2>
<table id="attributes" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><a href="#cell" class="attribute_list" >cell</a></td><td>&nbsp; 只读 <a href="MAILBOX.html">MAILBOX</a>
</td></tr>

<tr valign=top><td><a href="#cellData" class="attribute_list" >cellData</a></td><td>&nbsp; <a href="CELLDATADICT.html">CELLDATADICT</a>
</td></tr>

<tr valign=top><td><a href="#className" class="attribute_list" >className</a></td><td>&nbsp; 只读 <a href="STRING.html">string</a>
</td></tr>

<tr valign=top><td><a href="#client" class="attribute_list" >client</a></td><td>&nbsp; 只读 <a href="MAILBOX.html">MAILBOX</a>
</td></tr>

<tr valign=top><td><a href="#databaseID" class="attribute_list" >databaseID</a></td><td>&nbsp; 只读 <a href="int64.html">int64</a>
</td></tr>

<tr valign=top><td><a href="#id" class="attribute_list" >id</a></td><td>&nbsp; 只读 <a href="int32.html">int32</a>
</td></tr>

<tr valign=top><td><a href="#isDestroyed" class="attribute_list" >isDestroyed</a></td><td>&nbsp; <a href="bool.html">bool</a>
</td></tr>

<tr valign=top><td><a href="#shouldAutoArchive" class="attribute_list" >shouldAutoArchive</a></td><td>&nbsp; True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>

<tr valign=top><td><a href="#shouldAutoBackup" class="attribute_list" >shouldAutoBackup</a></td><td>&nbsp; True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>

<tr valign=top><td><a href="#spaceID" class="attribute_list" >spaceID</a></td><td>&nbsp; uint32
</td></tr>

</table>

<hr>
<a name="detailed_description"></a><h2>详细描述</h2>
类<a href="Base.html">Base</a>代表一个驻留在baseapp上的实体。 <a href="Base.html">Base</a>
实体可以通过<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#createBase>createBase</a>函数(以及以createBase为前缀的函数)创建。一个base实体实例也可以通过cellapp的函数<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#createEntityOnBaseApp>createEntityOnBaseApp</a>远程调用。
<br><br>
一个base实体可以在一个活动的cells里面链接到一个实体，还可以被用来在一个合适的cell上创建一个关联的实体。
这个类允许你创建和销毁在cell上的实体，在base实体上注册一个定时器的回调函数，访问此对象的联系信息，还可以访问
一个<a href="CellEntityMailBox.html">CellEntityMailBox</a>，通过它这个base实体可以与它的cell实体通信（这个被关联的cell实体可以移动到不同
cell上，作为该cell实体移动的结果，或负载均衡）。

<hr>
<h2>成员函数文档</h2>

<a name="addTimer"></a><p class="function_definition">
<span class="function_definition">def addTimer( <i>self, initialOffset, repeatOffset=0, userArg=0</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
函数addTimer注册回调函数<i>onTimer</i>，回调函数将在"initialOffset"秒后被执行第1次，而后将每间隔"repeatOffset"秒执行1次，可透传用户参数"userArg"（仅限integer类型）。
<br><br>
<i>onTimer</i> 函数必须在entity的base部分被定义，且带有2个参数，第1个integer类型的是timer的id（可用于移除timer的"delTimer"函数），第2个是用户透传的参数"userArg"。
<br><br>
例子:

<pre><pre># 这里是使用addTimer的一个例子
import <a href="../Modules/KBEngine.html">KBEngine</a>
&nbsp;
class MyBaseEntity( <a href="../Modules/KBEngine.html">KBEngine</a>.<a href="Base.html">Base</a> ):
&nbsp;
    def __init__( self ):
        <a href="../Modules/KBEngine.html">KBEngine</a>.<a href="Base.html">Base</a>.__init__( self )
&nbsp;
        # 增加一个定时器，5秒后执行第1次，而后每1秒执行1次，用户参数是9
        self.addTimer( 5, 1, 9 )
&nbsp;
        # 增加一个定时器，1秒后执行，用户参数缺省是0
        self.addTimer( 1 )
&nbsp;
    # 增加到一个<a href="Base.html">Base</a>的定时器有"onTimer" 作为它们定时器的函数被调用
    def onTimer( self, id, userArg ):
        print "MyBaseEntity.onTimer called: id %i, userArg: %i" % ( id, userArg )
        # if 这是不断重复的定时器，当不再需要该定时器的时候，调用下面函数移除:
        #     self.delTimer( id )</pre>
</pre>
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>initialOffset</i></span></td><td><span class="function_parameter_description">
initialOffset是float类型参数，
指定从定时器的注册到第一次回调的时间间隔（单位秒）。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>repeatOffset</i></span></td><td><span class="function_parameter_description">
repeatOffset一个可选的float类型参数，
指定第一次回调执行后每次执行的时间间隔（单位秒）。必须用函数delTimer移除定时器，否则它会一直重复下去。值小于等于0将被忽略。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>userArg</i></span></td><td><span class="function_parameter_description">
userArg是一个可选的integer类型参数，
指定用户提供传给base实体"onTimer"函数的数值。
</span></td></tr>

</table>
</p>

<p>
<span class="function_return">返回:</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>integer. 该函数返回timer的内部id，这个id可用于delTimer移除定时器。
</td></tr>
</table>
</p>

<a name="createCellEntity"></a><p class="function_definition">
<span class="function_definition">def createCellEntity( <i>self, cellEntityMB</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
请求在一个cell里面创建一个关联的实体。
<br><br>
用于创建cell实体的信息被存储在该实体的属性cellData里。这个属性是一个字典，对应实体的.def文件里的值加上用于表示
实体位置和方向(roll, pitch, yaw)的"position", "direction" 和 "spaceID"。
<br><br>
如果cellEntityMB没有传进来，cellData的"spaceID"用来指定是哪个空间创建这个cell实体的。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>cellEntityMB</i></span></td><td><span class="function_parameter_description">
一个可选的<a href="CellEntityMailBox.html">CellEntityMailBox</a>参数，
指定哪个空间里创建这个cell实体的。理想情况下，这两个实体接近使得可以容易地立刻找到正确的cell。
<br><br>
只能使用一个直接的cell mailbox。如果你有一个附近实体的base mailbox，你不可以使用<i>baseMailbox.cell</i>传给这个函数。
你必须在这个附近实体的base上创建一个新的函数来回传这个直接的cell mailbox。例如：
<pre>baseMailboxOfNearbyEntity.createCellNearSelf( self )</pre>
在附近实体的base上：
<pre>def createCellNearSelf( self, baseMailbox ):
    baseMailbox.createCellNearHere( self.cell )</pre>
在原实体的base上调用createCellNearSelf()方法：
<pre>def createCellNearHere( self. cellMailbox ):
    self.createCellEntity( cellMailbox )</pre>
</span></td></tr>

</table>
</p>

<a name="createInNewSpace"></a><p class="function_definition">
<span class="function_definition">def createInNewSpace( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
在一个空间的cell上创建一个关联的实体，它请求通过cell manager创建它的新的实体。
<br><br>
用于创建cell实体的信息被存储在该实体的属性cellData里。这个属性是一个字典，对应实体的.def文件里的值加上用于表示
实体位置和方向(roll, pitch, yaw)的"position", "direction" 和 "spaceID"。
</div>

<a name="delTimer"></a><p class="function_definition">
<span class="function_definition">def delTimer( <i>self, id</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
函数delTimer用于移除一个注册的定时器，移除后的定时器不再执行。只执行1次的定时器在执行回调后自动移除，不必要使用delTimer移除。
如果delTimer函数使用一个无效的id（例如已经移除），将会产生错误。
<br><br>
到<a href="Base.html">Base</a>.<a href=Base.html#addTimer>addTimer</a>参考定时器的一个使用例子。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>id</i></span></td><td><span class="function_parameter_description">
id是一个integer类型参数，它指定要移除的定时器id。
</span></td></tr>

</table>
</p>

<a name="destroy"></a><p class="function_definition">
<span class="function_definition">def destroy( <i>self, deleteFromDB, writeToDB</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
这个函数销毁该实体的base部分。它只能在没有实体的cell部分的时候才能被调用，否则将会产生错误。要销毁实体的cell部分，调用<a href="Base.html">Base</a>.<a href=Base.html#destroyCellEntity>destroyCellEntity</a>。
<br><br>
也许在onLoseCell回调里调用self.destroy更为恰当。这能保证实体的base部分被销毁。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>deleteFromDB</i></span></td><td><span class="function_parameter_description">
如果是True，在数据库里与这个实体有关联的条目将会被删除，该参数默认为False。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>writeToDB</i></span></td><td><span class="function_parameter_description">
如果是True，与这个实体相关联的属性将会写入数据库。这个仅仅会在这个实体是从数据库读取的，或者是使用过<a href="Base.html">Base</a>.<a href=Base.html#writeToDB>writeToDB</a>写入数据库才会被执行。这个参数默认为True，但当deleteFromDB为True的时候它将被忽略。
</span></td></tr>

</table>
</p>

<a name="destroyCellEntity"></a><p class="function_definition">
<span class="function_definition">def destroyCellEntity( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
<i>destroyCellEntity</i>请求销毁关联的cell实体。如果没有关联的cell实体该方法将会产生错误。
</div>

<a name="teleport"></a><p class="function_definition">
<span class="function_definition">def teleport( <i>self, baseEntityMB</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
<i>teleport</i>会瞬移这个实体的cell部分到参数指定的实体所在的空间。
<br><br>
在抵达新的空间后，Entity.onTeleportSuccess被调用。这可以用来在新的空间里移动该实体到合适的位置。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>baseEntityMB</i></span></td><td><span class="function_parameter_description">
实体应该移到的指定实体所在的空间，baseEntityMB即指定实体的mailbox。当成功的时候，与此参数相关联的cell实体会被传入到Entity.onTeleportSuccess函数。
</span></td></tr>

</table>
</p>

<a name="writeToDB"></a><p class="function_definition">
<span class="function_definition">def writeToDB( <i>self, callback, shouldAutoLoad</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
该函数保存这个实体的属性到数据库，使得以后当需要的时候可以重新加载。
<br><br>
实体也可以被标记为自动加载，这样当服务启动后实体将会被重新创建。自动加载的数据可以使用数据库的clear_auto_load工具清楚。
参考Server Operations Guide -> MySQL Support -> The clear_auto_load获得更多详细信息。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>callback</i></span></td><td><span class="function_parameter_description">
这个可选参数是当数据库操作完成后的回调函数。
它有两个参数。第一个是boolean类型标志成功或失败，第二个是base实体。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>shouldAutoLoad</i></span></td><td><span class="function_parameter_description">
这个可选参数指定这个实体在服务启动的时候是否需要从数据库加载。
</span></td></tr>

</table>
</p>

<hr>
<h2>回调函数文档</h2>

<a name="onCreateCellFailure"></a><p class="function_definition">
<span class="function_definition">def onCreateCellFailure( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在cell实体创建失败的时候被调用。
这个函数没有参数。
</div>

<a name="onDestroy"></a><p class="function_definition">
<span class="function_definition">def onDestroy( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在调用<a href="Base.html">Base</a>.<a href=Base.html#destroy>destroy</a>()后，在实际销毁之前被调用。
这个函数没有参数。
</div>

<a name="onGetCell"></a><p class="function_definition">
<span class="function_definition">def onGetCell( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在它获得cell实体的时候被调用。
这个函数没有参数。
</div>

<a name="onLoseCell"></a><p class="function_definition">
<span class="function_definition">def onLoseCell( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在它关联的cell实体销毁之后被调用。
这个函数没有参数。
</div>

<a name="onPreArchive"></a><p class="function_definition">
<span class="function_definition">def onPreArchive( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在该实体自动写入数据库之前被调用。这个回调在<a href="Base.html">Base</a>.<a href=Base.html#onWriteToDB>onWriteToDB</a>回调之前被调用，
cell部分的属性没有被提供。如果该回调返回False，该归档操作中止。这个回调应该返回True使得操作继续。如果这个回调不存在，则归档操作继续进行。
</div>

<a name="onRestore"></a><p class="function_definition">
<span class="function_definition">def onRestore( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在<a href="Base.html">Base</a>应用程序崩溃后在其它<a href="Base.html">Base</a>应用程序上
重新创建该实体时被调用。
这个函数没有参数。
</div>

<a name="onTimer"></a><p class="function_definition">
<span class="function_definition">def onTimer( <i>self, timerHandle, userData</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
这个函数当一个与此实体关联的定时器触发的时候被调用。
一个定时器可以使用<a href="Base.html">Base</a>.<a href=Base.html#addTimer>addTimer</a>函数添加。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>timerHandle</i></span></td><td><span class="function_parameter_description">
定时器的id。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>userData</i></span></td><td><span class="function_parameter_description">
传进<a href="Base.html">Base</a>.<a href=Base.html#addTimer>addTimer</a>的integer用户数据。
</span></td></tr>

</table>
</p>

<a name="onWriteToDB"></a><p class="function_definition">
<span class="function_definition">def onWriteToDB( <i>self, cellData</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在实体数据将要写进数据库的时候被调用。
<br><br>
需要注意的是在该回调里调用writeToDB会导致无限循环。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>cellData</i></span></td><td><span class="function_parameter_description">
cellData包含将要存进数据库的cell属性。
cellData是一个字典。
</span></td></tr>

</table>
</p>

<hr>
<h2>属性文档</h2>

<a name="cell"></a><p class="attribute_definition">
<span class="attribute_definition">cell</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
cell是用于联系cell实体的<a href="MAILBOX.html">MAILBOX</a>。这个属性是只读的，且如果这个base实体没有关联的cell时引用cell将产生错误。
<br><br>
需要注意的是当实体有一个cell mailbox但它还没有指向正确的CellApp时将要花费一段时间，这段时间就是在<a href="Base.html">Base</a>.<a href=Base.html#createCellEntity>createCellEntity</a>()调用之后
但<a href="Base.html">Base</a>.<a href=Base.html#onGetCell>onGetCell</a>()回调还没被调用期间。在这个期间，这个mailbox仍可被使用于从base实体直接发出但
不能被使用。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 <a href="MAILBOX.html">MAILBOX</a>
</td></tr>
</table>
</p>

<a name="cellData"></a><p class="attribute_definition">
<span class="attribute_definition">cellData</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
cellData是一个字典属性。每当base实体没有创建它的cell实体时，cell实体的属性会保存在这里。
<br><br>
如果cell实体被创建，这些用到的值和cellData属性将被删除。除了cell实体在实体定义文件里指定的属性外，它还包含position, direction and
spaceID。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td><a href="CELLDATADICT.html">CELLDATADICT</a>
</td></tr>
</table>
</p>

<a name="className"></a><p class="attribute_definition">
<span class="attribute_definition">className</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
实体的类名。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 string
</td></tr>
</table>
</p>

<a name="client"></a><p class="attribute_definition">
<span class="attribute_definition">client</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
client是用于联系客户端的mailbox。这个属性是只读的，且如果这个base实体没有关联的客户端时引用client将产生错误。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 <a href="MAILBOX.html">MAILBOX</a>
</td></tr>
</table>
</p>

<a name="databaseID"></a><p class="attribute_definition">
<span class="attribute_definition">databaseID</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
databaseID是实体的永久ID。这个id是int64类型且>0，如果是0则表示该实体不是永久的。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 int64
</td></tr>
</table>
</p>

<a name="id"></a><p class="attribute_definition">
<span class="attribute_definition">id</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
id是实体的对象id。这个id是一个整型，在base，cell和client相关联的实体之间是相同的。
这个属性是只读的。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 int32
</td></tr>
</table>
</p>

<a name="isDestroyed"></a><p class="attribute_definition">
<span class="attribute_definition">isDestroyed</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
如果该<a href="Base.html">Base</a>实体已经被销毁了，这个属性为True。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>bool
</td></tr>
</table>
</p>

<a name="shouldAutoArchive"></a><p class="attribute_definition">
<span class="attribute_definition">shouldAutoArchive</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
这个属性决定了自动存档的策略。如果设为True，自动存档将可用，如果设为False，自动存档将不可用。
如果设为<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>，自动存档将在下一个预定的时间可用，
在下一次存档后，这个属性将置为False。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>
</table>
</p>

<a name="shouldAutoBackup"></a><p class="attribute_definition">
<span class="attribute_definition">shouldAutoBackup</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
这个属性决定了自动备份的策略。如果设为True，自动备份将可用，如果设为False，自动备份将不可用。
如果设为<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>，自动备份将在下一个预定的时间可用，
在下一次备份后，这个属性将置为False。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>
</table>
</p>

<a name="spaceID"></a><p class="attribute_definition">
<span class="attribute_definition">spaceID</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
这是当前包含该实体的空间的唯一标识。它在base和cell应用程序之间是相同的。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 uint32
</td></tr>
</table>
</p>

<hr>
<p class="copyrightFooter">版权归KBEngine所有。</p>
</body>
</html>