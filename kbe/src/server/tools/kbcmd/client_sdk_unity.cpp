/*
This source file is part of KBEngine
For the latest info, see http://www.kbengine.org/

Copyright (c) 2008-2017 KBEngine.

KBEngine is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

KBEngine is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public License
along with KBEngine.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "kbcmd.h"
#include "client_sdk.h"
#include "client_sdk_unity.h"	
#include "entitydef/entitydef.h"
#include "entitydef/scriptdef_module.h"
#include "entitydef/property.h"
#include "entitydef/method.h"
#include "entitydef/datatype.h"
#include "network/fixed_messages.h"

namespace KBEngine {	

static std::string headerBody = "/*\n\tGenerated by KBEngine!\n\tPlease do not modify this file!\n#REPLACE#\ttools = kbcmd\n*/\n\n";
static std::string moduleSuffix = "Base";

//-------------------------------------------------------------------------------------
ClientSDKUnity::ClientSDKUnity():
	ClientSDK(),
	initBody_()
{
}

//-------------------------------------------------------------------------------------
ClientSDKUnity::~ClientSDKUnity()
{

}

//-------------------------------------------------------------------------------------
std::string ClientSDKUnity::typeToType(const std::string& type)
{
	if (type == "INT8")
	{
		return "SByte";
	}
	else if (type == "INT16")
	{
		return "Int16";
	}
	else if (type == "INT32")
	{
		return "Int32";
	}
	else if (type == "INT64")
	{
		return "Int64";
	}
	else if (type == "UINT8")
	{
		return "Byte";
	}
	else if (type == "UINT16")
	{
		return "UInt16";
	}
	else if (type == "UINT32")
	{
		return "UInt32";
	}
	else if (type == "UINT64")
	{
		return "UInt64";
	}
	else if (type == "FLOAT")
	{
		return "float";
	}
	else if (type == "DOUBLE")
	{
		return "double";
	}
	else if (type == "STRING")
	{
		return "string";
	}
	else if (type == "UNICODE")
	{
		return "string";
	}
	else if (type == "PYTHON")
	{
		return type;
	}
	else if (type == "PY_DICT")
	{
		return type;
	}
	else if (type == "PY_TUPLE")
	{
		return type;
	}
	else if (type == "PY_LIST")
	{
		return type;
	}
	else if (type == "BLOB")
	{
		return "byte[]";
	}
	else if (type == "ARRAY")
	{
		return "List";
	}
	else if (type == "FIXED_DICT")
	{
		return "Dictionary";
	}
#ifdef CLIENT_NO_FLOAT
	else if (type == "VECTOR2")
	{
		return "Vector2Int";
	}
	else if (type == "VECTOR3")
	{
		return "Vector3Int";
	}
	else if (type == "VECTOR4")
	{
		return "Vector4Int";
	}
#else
	else if (type == "VECTOR2")
	{
		return "Vector2";
	}
	else if (type == "VECTOR3")
	{
		return "Vector3";
	}
	else if (type == "VECTOR4")
	{
		return "Vector4";
	}
#endif
	else if (type == "MAILBOX")
	{
		return "byte[]";
	}

	return type;
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateTypeFileName()
{
	sourcefileName_ = "KBETypes.cs";
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateEntityModuleFileName(const std::string& moduleName)
{
	sourcefileName_ = moduleName + moduleSuffix + ".cs";
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateServerErrorDescrsModuleFileName()
{
	sourcefileName_ = "ServerErrorDescrs.cs";
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateEngineMessagesModuleFileName()
{
	sourcefileName_ = "Messages.cs";
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeServerErrorDescrsModuleBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += fmt::format("\tpublic struct {}\n\t{{\n\t\tpublic string name;\n\t\tpublic string descr;\n\t\tpublic UInt16 id;\n", "ServerErr");
	sourcefileBody_ += "\t}";

	sourcefileBody_ += "\n\n\t// defined in */res/server/server_errors.xml\n\n";
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", "ServerErrorDescrs");
	sourcefileBody_ += "\t\tpublic static Dictionary<UInt16, ServerErr> serverErrs = new Dictionary<UInt16, ServerErr>();\n\n";

	sourcefileBody_ += "\t\tpublic ServerErrorDescrs()\n\t\t{\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeServerErrorDescrsModuleErrDescr(int errorID, const std::string& errname, const std::string& errdescr)
{
	sourcefileBody_ += fmt::format("\t\t\t{{\n\t\t\t\tServerErr e;\n\t\t\t\te.id = {};\n\t\t\t\te.name = \"{}\";\n\t\t\t\te.descr = \"{}\";\n\n\t\t\t\tserverErrs.Add(e.id, e);\n", errorID, errname, errdescr);
	sourcefileBody_ += "\t\t\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeServerErrorDescrsModuleEnd()
{
	sourcefileBody_ += "\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic void Clear()\n\t\t{\n\t\t\tserverErrs.Clear();\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic string serverErrStr(UInt16 id)\n\t\t{\n\t\t\tServerErr e;\n\t\t\tif(!serverErrs.TryGetValue(id, out e))\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn e.name + \"[\" + e.descr + \"]\";\n\t\t}\n\n";
	sourcefileBody_ += "\t\tpublic ServerErr serverErr(UInt16 id)\n\t\t{\n\t\t\tServerErr e;\n\t\t\tserverErrs.TryGetValue(id, out e);\n\t\t\treturn e;\n\t\t}\n\n";

	sourcefileBody_ += "\n\n\n\t}\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEngineMessagesModuleBegin()
{
	initBody_ = "";
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += "\tusing MessageID = System.UInt16;\n\n";

	sourcefileBody_ += "\t// engine-c++ messages\n\n";
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", "Message");

	sourcefileBody_ += "\t\tpublic MessageID id = 0;\n";
	sourcefileBody_ += "\t\tpublic string name;\n";
	sourcefileBody_ += "\t\tpublic Int16 msglen = -1;\n";
	sourcefileBody_ += "\t\tpublic KBEDATATYPE_BASE[] argtypes = null;\n";
	sourcefileBody_ += "\t\tpublic sbyte argsType = 0;\n";

	sourcefileBody_ += "\n\t\tpublic Message(MessageID msgid, string msgname, Int16 length, sbyte argstype, List<Byte> msgargtypes)\n\t\t{\n";
	sourcefileBody_ += "\t\t\tid = msgid;\n";
	sourcefileBody_ += "\t\t\tname = msgname;\n";
	sourcefileBody_ += "\t\t\tmsglen = length;\n";
	sourcefileBody_ += "\t\t\targsType = argstype;\n\n";

	sourcefileBody_ += "\t\t\targtypes = new KBEDATATYPE_BASE[msgargtypes.Count];\n";
	sourcefileBody_ += "\t\t\tfor(int i=0; i<msgargtypes.Count; i++)\n";
	sourcefileBody_ += "\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\tif(!EntityDef.id2datatypes.TryGetValue(msgargtypes[i], out argtypes[i]))\n";
	sourcefileBody_ += "\t\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\t\tDbg.ERROR_MSG(\"Message::Message() : argtype(\" + msgargtypes[i] + \") is not found!\");\n";
	sourcefileBody_ += "\t\t\t\t}\n";
	sourcefileBody_ += "\t\t\t}\n\n";

	sourcefileBody_ += "\t\t\t// Dbg.DEBUG_MSG(string.Format(\"Message::Message() : ({ 0 } / {1} / {2})!\", \n";
	sourcefileBody_ += "\t\t\t//\t\tmsgname, msgid, msglen));";

	sourcefileBody_ += "\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic virtual object[] createFromStream(MemoryStream msgstream)\n";
	sourcefileBody_ += "\t\t{\n";
	sourcefileBody_ += "\t\t\tif(argtypes.Length <= 0)\n";
	sourcefileBody_ += "\t\t\t\treturn new object[]{msgstream};\n\n";
	sourcefileBody_ += "\t\t\tobject[] result = new object[argtypes.Length];\n\n";
	sourcefileBody_ += "\t\t\tfor(int i=0; i<argtypes.Length; i++)\n";
	sourcefileBody_ += "\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\tresult[i] = argtypes[i].createFromStream(msgstream);\n";
	sourcefileBody_ += "\t\t\t}\n\n";
	sourcefileBody_ += "\t\t\treturn result;\n";
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic virtual void handleMessage(MemoryStream msgstream)\n";
	sourcefileBody_ += "\t\t{\n";
	sourcefileBody_ += "\t\t}\n";

	sourcefileBody_ += "\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEngineMessagesModuleMessage(Network::ExposedMessageInfo& messageInfos, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("\tpublic class Message_{} : Message\n\t{{\n", messageInfos.name);

	sourcefileBody_ += fmt::format("\n\t\tpublic Message_{}(MessageID msgid, string msgname, Int16 length, sbyte argstype, List<Byte> msgargtypes):\n\t\t\tbase(msgid, msgname, length, argstype, msgargtypes)\n\t\t{{\n", messageInfos.name);
	sourcefileBody_ += "\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic override void handleMessage(MemoryStream msgstream)\n";
	sourcefileBody_ += "\t\t{\n";

	if (messageInfos.argsTypes.size() == 0)
	{
		initBody_ += fmt::format("\t\t\tMessages.messages[\"{}\"] = new Message_{}({}, \"{}\", {}, {}, ", 
			messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType);

		initBody_ += "new List<Byte>());\n";

		if (componentType == CLIENT_TYPE)
		{
			if (messageInfos.argsType < 0)
			{
				sourcefileBody_ += fmt::format("\t\t\tKBEngineApp.app.{}(msgstream);\n", messageInfos.name);
			}
			else
			{
				sourcefileBody_ += fmt::format("\t\t\tKBEngineApp.app.{}();\n", messageInfos.name);
			}
		}
	}
	else
	{
		std::string argsparse = "";
		std::string giveargs = "";
		initBody_ += fmt::format("\n\t\t\tList<Byte> {}_argstypes = new List<Byte>();\n", messageInfos.name);

		for (int i = 0; i < (int)messageInfos.argsTypes.size(); ++i)
		{
			int argindex = (i + 1);
			std::string nativetype = datatype2nativetype(messageInfos.argsTypes[i]);

			KBE_ASSERT(nativetype != "FIXED_DICT" && nativetype != "ARRAY" && nativetype != "PYTHON" && nativetype != "MAILBOX");

			argsparse += fmt::format("\t\t\t{} arg{} = ({})argtypes[{}].createFromStream(msgstream);\n", typeToType(nativetype), argindex, typeToType(nativetype), i);
			giveargs += fmt::format("arg{}, ", argindex);
			initBody_ += fmt::format("\t\t\t{}_argstypes.Add({});\n", messageInfos.name, (int)messageInfos.argsTypes[i]);
		}

		if (giveargs.size() > 0)
			giveargs.erase(giveargs.size() - 2, 2);

		initBody_ += fmt::format("\t\t\tMessages.messages[\"{}\"] = new Message_{}({}, \"{}\", {}, {}, {}_argstypes);\n", 
			messageInfos.name, messageInfos.name, messageInfos.id, messageInfos.name, messageInfos.msgLen, (int)messageInfos.argsType, messageInfos.name);
		
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += argsparse;
			sourcefileBody_ += fmt::format("\t\t\tKBEngineApp.app.{}({});\n", messageInfos.name, giveargs);
		}
	}

	if (componentType == CLIENT_TYPE)
	{
		initBody_ += fmt::format("\t\t\tMessages.clientMessages[{}] = Messages.messages[\"{}\"];\n\n", messageInfos.id, messageInfos.name);
	}
	else if (componentType == LOGINAPP_TYPE)
	{
		initBody_ += fmt::format("\t\t\tMessages.loginappMessages[{}] = Messages.messages[\"{}\"];\n\n", messageInfos.id, messageInfos.name);
	}
	else if (componentType == BASEAPP_TYPE)
	{
		initBody_ += fmt::format("\t\t\tMessages.baseappMessages[{}] = Messages.messages[\"{}\"];\n\n", messageInfos.id, messageInfos.name);
	}

	sourcefileBody_ += "\t\t}\n";

	sourcefileBody_ += "\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEngineMessagesModuleEnd()
{
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", "Messages");

	sourcefileBody_ += "\t\tpublic static Dictionary<MessageID, Message> loginappMessages = new Dictionary<MessageID, Message>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<MessageID, Message> baseappMessages = new Dictionary<MessageID, Message>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<MessageID, Message> clientMessages = new Dictionary<MessageID, Message>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<string, Message> messages = new Dictionary<string, Message>();\n";

	sourcefileBody_ += "\n\t\tpublic static void clear()\n\t\t{\n";

	sourcefileBody_ += "\t\t\tloginappMessages = new Dictionary<MessageID, Message>();\n";
	sourcefileBody_ += "\t\t\tbaseappMessages = new Dictionary<MessageID, Message>();\n";
	sourcefileBody_ += "\t\t\tclientMessages = new Dictionary<MessageID, Message>();\n";
	sourcefileBody_ += "\t\t\tmessages = new Dictionary<string, Message>();\n";
	sourcefileBody_ += "\n\t\t\tinit();";

	sourcefileBody_ += "\n\t\t}\n\n";

	sourcefileBody_ += "\n\t\tpublic static bool init()\n\t\t{\n";

	sourcefileBody_ += initBody_;

	sourcefileBody_ += "\n\t\t\treturn true;";
	sourcefileBody_ += "\n\t\t}";
	sourcefileBody_ += "\n\t}";
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateEntityDefsModuleFileName()
{
	sourcefileName_ = "EntityDef.cs";
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityDefsModuleBegin()
{
	initBody_ = "";
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", "EntityDef");

	sourcefileBody_ += "\t\tpublic static Dictionary<string, UInt16> datatype2id = new Dictionary<string, UInt16>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<string, KBEDATATYPE_BASE> datatypes = new Dictionary<string, KBEDATATYPE_BASE>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<UInt16, KBEDATATYPE_BASE> id2datatypes = new Dictionary<UInt16, KBEDATATYPE_BASE>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<string, Int32> entityclass = new Dictionary<string, Int32>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<string, ScriptModule> moduledefs = new Dictionary<string, ScriptModule>();\n";
	sourcefileBody_ += "\t\tpublic static Dictionary<UInt16, ScriptModule> idmoduledefs = new Dictionary<UInt16, ScriptModule>();\n";

	sourcefileBody_ += "\n\t\tpublic static bool init()\n\t\t{\n";
	sourcefileBody_ += "\t\t\tinitDataType();\n";
	sourcefileBody_ += "\t\t\tbindMessageDataType();\n";
	sourcefileBody_ += "\t\t\tupdateTypes();\n";
	sourcefileBody_ += "\t\t\tinitScriptModules();\n";
	sourcefileBody_ += "\t\t\treturn true;\n";
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\n\t\tpublic static bool reset()\n\t\t{\n";
	sourcefileBody_ += "\t\t\tclear();\n";
	sourcefileBody_ += "\t\t\tinitDataType();\n";
	sourcefileBody_ += "\t\t\tbindMessageDataType();\n";
	sourcefileBody_ += "\t\t\treturn true;\n";
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic static void clear()\n";
	sourcefileBody_ += "\t\t{\n";
	sourcefileBody_ += "\t\t\tdatatype2id.Clear();\n";
	sourcefileBody_ += "\t\t\tdatatypes.Clear();\n";
	sourcefileBody_ += "\t\t\tid2datatypes.Clear();\n";
	sourcefileBody_ += "\t\t\tentityclass.Clear();\n";
	sourcefileBody_ += "\t\t\tmoduledefs.Clear();\n";
	sourcefileBody_ += "\t\t\tidmoduledefs.Clear();\n";
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic static void initDataType()\n";
	sourcefileBody_ += "\t\t{\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"UINT8\"] = new KBEDATATYPE_UINT8();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"UINT16\"] = new KBEDATATYPE_UINT16();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"UINT32\"] = new KBEDATATYPE_UINT32();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"UINT64\"] = new KBEDATATYPE_UINT64();\n\n";

	sourcefileBody_ += "\t\t\tdatatypes[\"INT8\"] = new KBEDATATYPE_INT8();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"INT16\"] = new KBEDATATYPE_INT16();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"INT32\"] = new KBEDATATYPE_INT32();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"INT64\"] = new KBEDATATYPE_INT64();\n\n";

	sourcefileBody_ += "\t\t\tdatatypes[\"FLOAT\"] = new KBEDATATYPE_FLOAT();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"DOUBLE\"] = new KBEDATATYPE_DOUBLE();\n\n";

	sourcefileBody_ += "\t\t\tdatatypes[\"STRING\"] = new KBEDATATYPE_STRING();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"VECTOR2\"] = new KBEDATATYPE_VECTOR2();\n\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"VECTOR3\"] = new KBEDATATYPE_VECTOR3();\n\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"VECTOR4\"] = new KBEDATATYPE_VECTOR4();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"PYTHON\"] = new KBEDATATYPE_PYTHON();\n\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"UNICODE\"] = new KBEDATATYPE_UNICODE();\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"MAILBOX\"] = new KBEDATATYPE_MAILBOX();\n\n";
	sourcefileBody_ += "\t\t\tdatatypes[\"BLOB\"] = new KBEDATATYPE_BLOB();\n";
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic static void bindMessageDataType()\n";
	sourcefileBody_ += "\t\t{\n";
	sourcefileBody_ += "\t\t\tif(datatype2id.Count > 0)\n";
	sourcefileBody_ += "\t\t\t\treturn;\n\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"STRING\"] = 1;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"STD::STRING\"] = 1;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[1] = datatypes[\"STRING\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"UINT8\"] = 2;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"BOOL\"] = 2;\n\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"DATATYPE\"] = 2;\n\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"CHAR\"] = 2;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"DETAIL_TYPE\"] = 2;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"MAIL_TYPE\"] = 2;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[2] = datatypes[\"UINT8\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"UINT16\"] = 3;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"UNSIGNED SHORT\"] = 3;\n\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"SERVER_ERROR_CODE\"] = 3;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"ENTITY_TYPE\"] = 3;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"ENTITY_PROPERTY_UID\"] = 3;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"ENTITY_METHOD_UID\"] = 3;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"ENTITY_SCRIPT_UID\"] = 3;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"DATATYPE_UID\"] = 3;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[3] = datatypes[\"UINT16\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"UINT32\"] = 4;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"UINT\"] = 4;\n\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"UNSIGNED INT\"] = 4;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"ARRAYSIZE\"] = 4;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"SPACE_ID\"] = 4;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"GAME_TIME\"] = 4;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"TIMER_ID\"] = 4;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[4] = datatypes[\"UINT32\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"UINT64\"] = 5;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"DBID\"] = 5;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"COMPONENT_ID\"] = 5;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[5] = datatypes[\"UINT64\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"INT8\"] = 6;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"COMPONENT_ORDER\"] = 6;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[6] = datatypes[\"INT8\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"INT16\"] = 7;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"SHORT\"] = 7;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[7] = datatypes[\"INT16\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"INT32\"] = 8;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"INT\"] = 8;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"ENTITY_ID\"] = 8;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"CALLBACK_ID\"] = 8;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"COMPONENT_TYPE\"] = 8;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[8] = datatypes[\"INT32\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"INT64\"] = 9;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[9] = datatypes[\"INT64\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"PYTHON\"] = 10;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"PY_DICT\"] = 10;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"PY_TUPLE\"] = 10;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"PY_LIST\"] = 10;\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"MAILBOX\"] = 10;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[10] = datatypes[\"PYTHON\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"BLOB\"] = 11;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[11] = datatypes[\"BLOB\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"UNICODE\"] = 12;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[12] = datatypes[\"UNICODE\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"FLOAT\"] = 13;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[13] = datatypes[\"FLOAT\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"DOUBLE\"] = 14;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[14] = datatypes[\"DOUBLE\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"VECTOR2\"] = 15;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[15] = datatypes[\"VECTOR2\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"VECTOR3\"] = 16;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[16] = datatypes[\"VECTOR3\"];\n\n";

	sourcefileBody_ += "\t\t\tdatatype2id[\"VECTOR4\"] = 17;\n";
	sourcefileBody_ += "\t\t\tid2datatypes[17] = datatypes[\"VECTOR4\"];\n\n";

	sourcefileBody_ += "\t\t\t// Dynamic binding\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"FIXED_DICT\"] = 18;\n";
	sourcefileBody_ += "\t\t\t//id2datatypes[18] = datatypes[\"FIXED_DICT\"];\n\n";

	sourcefileBody_ += "\t\t\t// Dynamic binding\n";
	sourcefileBody_ += "\t\t\tdatatype2id[\"ARRAY\"] = 19;\n";
	sourcefileBody_ += "\t\t\t//id2datatypes[19] = datatypes[\"ARRAY\"];\n";

	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic static void initScriptModules()\n";
	sourcefileBody_ += "\t\t{\n";
	
	
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityDefsModuleEnd()
{
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic static void updateTypes()\n";
	sourcefileBody_ += "\t\t{\n";

	const DataTypes::UID_DATATYPE_MAP& dataTypes = DataTypes::uid_dataTypes();
	DataTypes::UID_DATATYPE_MAP::const_iterator dtiter = dataTypes.begin();
	for (; dtiter != dataTypes.end(); ++dtiter)
	{
		const DataType* datatype = dtiter->second;

		if (!writeEntityDefModuleType(datatype))
			return false;
	}

	sourcefileBody_ += "\t\t\tforeach(string datatypeStr in EntityDef.datatypes.Keys)\n\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\tKBEDATATYPE_BASE dataType = EntityDef.datatypes[datatypeStr];\n";
	sourcefileBody_ += "\t\t\t\tif(dataType != null)\n\t\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\t\tdataType.bind();\n\t\t\t\t}\n\t\t\t}\n";

	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t}\n\n\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityDefModuleType(const DataType* pDataType)
{
	uint16 typeID = datatype2id(pDataType->getName());
	if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = pDataType->id();
		KBE_ASSERT(typeID > datatype2id("KBE_DATATYPE2ID_MAX"));
	}

	sourcefileBody_ += fmt::format("\t\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\t\tUInt16 utype = {};\n", typeID);
	sourcefileBody_ += fmt::format("\t\t\t\tstring valname = \"{}\";\n", (strlen(pDataType->aliasName()) > 0 ? pDataType->aliasName() : fmt::format("Null_{}", typeID)));

	if (strcmp(pDataType->getName(), "FIXED_DICT") == 0)
	{
		FixedDictType* dictdatatype = const_cast<FixedDictType*>(static_cast<const FixedDictType*>(pDataType));

		FixedDictType::FIXEDDICT_KEYTYPE_MAP& keys = dictdatatype->getKeyTypes();

		sourcefileBody_ += fmt::format("\t\t\t\tKBEDATATYPE_FIXED_DICT datatype = new KBEDATATYPE_FIXED_DICT();\n");
		sourcefileBody_ += fmt::format("\t\t\t\tdatatype.implementedBy = \"{}\";\n", dictdatatype->moduleName());

		FixedDictType::FIXEDDICT_KEYTYPE_MAP::const_iterator keyiter = keys.begin();
		for (; keyiter != keys.end(); ++keyiter)
		{
			typeID = datatype2id(keyiter->second->dataType->getName());
			if (typeID == 0 || strcmp(keyiter->second->dataType->getName(), "FIXED_DICT") == 0 || strcmp(keyiter->second->dataType->getName(), "ARRAY") == 0)
				typeID = pDataType->id();

			sourcefileBody_ += fmt::format("\t\t\t\tdatatype.dicttype[\"{}\"] = (UInt16){};\n", keyiter->first, typeID);
		}

		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes[valname] = datatype;\n");
	}
	else if (strcmp(pDataType->getName(), "ARRAY") == 0)
	{
		typeID = datatype2id(const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType))->getDataType()->getName());
		if (typeID == 0 || strcmp(const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType))->getDataType()->getName(), "FIXED_DICT") == 0 || 
			strcmp(const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType))->getDataType()->getName(), "ARRAY") == 0)
			typeID = const_cast<FixedArrayType*>(static_cast<const FixedArrayType*>(pDataType))->getDataType()->id();

		sourcefileBody_ += fmt::format("\t\t\t\tKBEDATATYPE_ARRAY datatype = new KBEDATATYPE_ARRAY();\n");
		sourcefileBody_ += fmt::format("\t\t\t\tdatatype.vtype = (UInt16){};\n", typeID);
		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes[valname] = datatype;\n");
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\t\tstring name = \"{}\";\n", pDataType->getName());
		sourcefileBody_ += fmt::format("\t\t\t\tKBEDATATYPE_BASE val = null;\n");
		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes.TryGetValue(name, out val);\n");
		sourcefileBody_ += fmt::format("\t\t\t\tEntityDef.datatypes[valname] = val;\n");
	}

	sourcefileBody_ += fmt::format("\n\t\t\t\tEntityDef.id2datatypes[utype] = EntityDef.datatypes[valname];\n");
	sourcefileBody_ += fmt::format("\n\t\t\t\tEntityDef.datatype2id[valname] = utype;\n");
	sourcefileBody_ += fmt::format("\t\t\t}}\n\n");

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityDefScriptModule(ScriptDefModule* pScriptDefModule)
{
	sourcefileBody_ += fmt::format("\t\t\tScriptModule p{}Module = new ScriptModule(\"{}\");\n", pScriptDefModule->getName(), pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\tEntityDef.moduledefs[\"{}\"] = p{}Module;\n", pScriptDefModule->getName(), pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\tEntityDef.idmoduledefs[{}] = p{}Module;\n\n", pScriptDefModule->getUType(), pScriptDefModule->getName());
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityDefMethodDescr(ScriptDefModule* pScriptDefModule, MethodDescription* pDescr, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("\t\t\tList<KBEDATATYPE_BASE> p{}_{}_args = new List<KBEDATATYPE_BASE>();\n", pScriptDefModule->getName(), pDescr->getName());

	const std::vector<DataType*>& args = pDescr->getArgTypes();
	std::vector<DataType*>::const_iterator argiter = args.begin();
	for (; argiter != args.end(); ++argiter)
	{
		uint16 typeID = datatype2id((*argiter)->getName());
		if (typeID == 0 || strcmp((*argiter)->getName(), "FIXED_DICT") == 0 || strcmp((*argiter)->getName(), "ARRAY") == 0)
			typeID = (*argiter)->id();

		sourcefileBody_ += fmt::format("\t\t\tp{}_{}_args.Add(EntityDef.id2datatypes[{}]);\n\n", pScriptDefModule->getName(), pDescr->getName(), typeID);
	}

	sourcefileBody_ += fmt::format("\t\t\tMethod p{}_{} = new Method();\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.name = \"{}\";\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.methodUtype = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.aliasID = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->aliasID());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.args = p{}_{}_args;\n\n", pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	sourcefileBody_ += fmt::format("\t\t\tSystem.Reflection.MethodInfo p{}_{}Handler = null;\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tif(p{}Module.script != null)\n\t\t\t{{\n", pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\t\ttry {{\n\t\t\t\t\tp{}_{}Handler = p{}Module.script.GetMethod(\"{}\");\n\t\t\t\t}}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{{\n",
		pScriptDefModule->getName(), pDescr->getName()
		, pScriptDefModule->getName(), pDescr->getName());

	sourcefileBody_ += fmt::format("\t\t\t\t\tstring err = \"EntityDef::initScriptModules: {}.{}(), error=\" + e.ToString();\n\t\t\t\t\tthrow new Exception(err);\n\t\t\t\t}}\n\t\t\t}}\n",
		pScriptDefModule->getName(), pDescr->getName());

	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.handler = p{}_{}Handler;\n", pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	sourcefileBody_ += fmt::format("\t\t\tp{}Module.methods[\"{}\"] = p{}_{}; \n\n",
		pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	if (pDescr->aliasID() != -1)
	{
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.useMethodDescrAlias = true;\n", pScriptDefModule->getName());
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idmethods[(UInt16)p{}_{}.aliasID] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
		else
		{
			KBE_ASSERT(false);
		}
	}
	else
	{
		if (componentType == CLIENT_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.useMethodDescrAlias = false;\n", pScriptDefModule->getName());
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idmethods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		} 
		if (componentType == BASEAPP_TYPE)
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.base_methods[\"{}\"] = p{}_{};\n\n",
				pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idbase_methods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\t\tp{}Module.cell_methods[\"{}\"] = p{}_{};\n\n",
				pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

			sourcefileBody_ += fmt::format("\t\t\tp{}Module.idcell_methods[p{}_{}.methodUtype] = p{}_{};\n\n",
				pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
		}
	}

	sourcefileBody_ += fmt::format("\t\t\t//Dbg.DEBUG_MSG(\"EntityDef::initScriptModules: add({}), method({} / {}).\");\n\n",
		pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityDefPropertyDescr(ScriptDefModule* pScriptDefModule, PropertyDescription* pDescr)
{
	std::string eventName = pDescr->getName();
	eventName[0] = std::toupper(eventName[0]);

	sourcefileBody_ += fmt::format("\t\t\tSystem.Reflection.MethodInfo p{}_{}Setmethod = null;\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tif(p{}Module.script != null)\n\t\t\t{{\n", pScriptDefModule->getName());
	sourcefileBody_ += fmt::format("\t\t\t\ttry {{\n\t\t\t\t\tp{}_{}Setmethod = p{}Module.script.GetMethod(\"on{}Changed\");\n\t\t\t\t}}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{{\n", 
		pScriptDefModule->getName(), pDescr->getName()
		, pScriptDefModule->getName(), eventName);

	sourcefileBody_ += fmt::format("\t\t\t\t\tstring err = \"EntityDef::initScriptModules: {}.on{}Changed, error=\" + e.ToString();\n\t\t\t\t\tthrow new Exception(err);\n\t\t\t\t}}\n\t\t\t}}\n", 
		pScriptDefModule->getName(), eventName);

	uint16 typeID = datatype2id(pDescr->getDataType()->getName());
	if (typeID == 0 || strcmp(pDescr->getDataType()->getName(), "FIXED_DICT") == 0 || strcmp(pDescr->getDataType()->getName(), "ARRAY") == 0)
		typeID = pDescr->getDataType()->id();

	sourcefileBody_ += fmt::format("\t\t\tProperty p{}_{} = new Property();\n", pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.name = \"{}\";\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.utype = EntityDef.id2datatypes[{}];\n", pScriptDefModule->getName(), pDescr->getName(), typeID);
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.properUtype = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.properFlags = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getFlags());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.aliasID = {};\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->aliasID());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.defaultValStr = \"{}\";\n", pScriptDefModule->getName(), pDescr->getName(), pDescr->getDefaultValStr());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.setmethod = p{}_{}Setmethod;\n", pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	sourcefileBody_ += fmt::format("\t\t\tp{}_{}.val = p{}_{}.utype.parseDefaultValStr(p{}_{}.defaultValStr);\n", 
		pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	sourcefileBody_ += fmt::format("\t\t\tp{}Module.propertys[\"{}\"] = p{}_{}; \n\n", 
		pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());

	if (pDescr->aliasID() != -1)
	{
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.usePropertyDescrAlias = true;\n", pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.idpropertys[(UInt16)p{}_{}.aliasID] = p{}_{};\n\n",
			pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.usePropertyDescrAlias = false;\n", pScriptDefModule->getName());
		sourcefileBody_ += fmt::format("\t\t\tp{}Module.idpropertys[p{}_{}.properUtype] = p{}_{};\n\n",
			pScriptDefModule->getName(), pScriptDefModule->getName(), pDescr->getName(), pScriptDefModule->getName(), pDescr->getName());
	}

	sourcefileBody_ += fmt::format("\t\t\t//Dbg.DEBUG_MSG(\"EntityDef::initScriptModules: add({}), property({} / {}).\");\n\n",
		pScriptDefModule->getName(), pDescr->getName(), pDescr->getUType());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypesBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += "\n\n\t// defined in */scripts/entity_defs/types.xml\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypesEnd()
{
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeBegin(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", typeName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeEnd(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeBegin(std::string typeName, FixedArrayType* pDataType, const std::string& parentClass)
{
	sourcefileBody_ += fmt::format("\tpublic class {}{}\n\t{{\n", typeName, (parentClass.size() > 0 ? std::string(" : ") + parentClass : ""));
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeEnd(std::string typeName, FixedArrayType* pDataType)
{
	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic SByte {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int16 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int32 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int64 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Byte {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt16 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt32 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt64 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_FLOAT(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic float {} = 0f;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_DOUBLE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic double {} = 0d;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_STRING(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UNICODE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PYTHON(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PYTHON(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PY_DICT(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PY_DICT(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PY_TUPLE(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PY_TUPLE(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PY_LIST(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PY_LIST(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_BLOB(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = new byte[0];\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_ARRAY(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	std::string new_childItemName = childItemName;

	if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
	{
		FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

		// 如果元素又是数组
		if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pDataType->aliasName(), fmt::format("List<{}>", pFixedArrayType->getDataType()->aliasName()));
			else
				new_childItemName = fmt::format("List<{}>", pFixedArrayType->getDataType()->aliasName());

			return writeTypeItemType_ARRAY(itemName, new_childItemName, pFixedArrayType->getDataType());
		}
		else if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pDataType->aliasName(), pFixedArrayType->getDataType()->aliasName());
			else
				new_childItemName = pFixedArrayType->getDataType()->aliasName();
		}
		else
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pDataType->aliasName(), typeToType(pFixedArrayType->getDataType()->getName()));
			else
				new_childItemName = typeToType(pFixedArrayType->getDataType()->getName());
		}
	}

	sourcefileBody_ += fmt::format("\t\tpublic List<{}> {} = new List<{}>();\n", new_childItemName, itemName, new_childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_FIXED_DICT(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", childItemName, itemName, childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_VECTOR2(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = new Vector2Int(0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector2 {} = new Vector2(0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_VECTOR3(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = new Vector3Int(0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector3 {} = new Vector2(0f, 0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_VECTOR4(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = new Vector4Int(0, 0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector4 {} = new Vector4(0f, 0f, 0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_MAILBOX(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = new byte[0];\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityModuleBegin(ScriptDefModule* pEntityScriptDefModule)
{
	std::string newModuleName = fmt::format("{}{}", pEntityScriptDefModule->getName(), moduleSuffix);

	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", fmt::format("\tPlease inherit this module, such as: (class {} : {}{})\n",
		pEntityScriptDefModule->getName(), pEntityScriptDefModule->getName(), moduleSuffix));

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += std::string("\t// defined in */scripts/entity_defs/") + pEntityScriptDefModule->getName() + ".def\n";

	sourcefileBody_ += fmt::format("\tpublic abstract class {} : Entity\n\t{{\n", newModuleName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityModuleEnd(ScriptDefModule* pEntityScriptDefModule)
{
	sourcefileBody_ += "\t}\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProcessMessagesMethod(ScriptDefModule* pEntityScriptDefModule)
{
	// 处理方法
	sourcefileBody_ += fmt::format("\n\t\tpublic override void onRemoteMethodCall(Method method, MemoryStream stream)\n\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\tswitch(method.methodUtype)\n\t\t\t{{\n");

	ScriptDefModule::METHODDESCRIPTION_MAP& clientMethods = pEntityScriptDefModule->getClientMethodDescriptions();
	ScriptDefModule::METHODDESCRIPTION_MAP::iterator methodIter = clientMethods.begin();
	for (; methodIter != clientMethods.end(); ++methodIter)
	{
		MethodDescription* pMethodDescription = methodIter->second;

		sourcefileBody_ += fmt::format("\t\t\t\tcase {}:\n", pMethodDescription->getUType());
		
		std::vector<DataType*>& argTypes = pMethodDescription->getArgTypes();
		std::vector<DataType*>::iterator iter = argTypes.begin();

		int i = 1;
		std::string argsStr;

		for (; iter != argTypes.end(); ++iter)
		{
			DataType* pDataType = (*iter);

			uint16 typeID = datatype2id(pDataType->getName());
			if (typeID == 0 || strcmp(pDataType->getName(), "FIXED_DICT") == 0 || strcmp(pDataType->getName(), "ARRAY") == 0)
				typeID = pDataType->id();

			argsStr += fmt::format("{}_arg{}, ", pMethodDescription->getName(), i);

			std::string nativetype = datatype2nativetype(typeID);
			if (strcmp(pDataType->getName(), "FIXED_DICT") != 0 && strcmp(pDataType->getName(), "ARRAY") != 0)
				sourcefileBody_ += fmt::format("\t\t\t\t\t{} {}_arg{} = ({})method.args[{}].createFromStream(stream);\n",
					typeToType(nativetype), pMethodDescription->getName(), i, typeToType(nativetype), (i - 1));
			else
				sourcefileBody_ += fmt::format("\t\t\t\t\t{} {}_arg{} = ({})method.args[{}].createFromStream(stream);\n",
					pDataType->aliasName(), pMethodDescription->getName(), i, pDataType->aliasName(), (i - 1));

			++i;
		}

		if (argsStr.size() > 0)
			argsStr.erase(argsStr.size() - 2, 2);

		sourcefileBody_ += fmt::format("\t\t\t\t\t{}({});\n", pMethodDescription->getName(), argsStr);
		sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\tdefault:\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	sourcefileBody_ += fmt::format("\t\t\t}};\n");
	sourcefileBody_ += "\t\t}\n";

	// 处理属性
	ENTITY_PROPERTY_UID posuid = 0;
	if (posuid == 0)
	{
		posuid = ENTITY_BASE_PROPERTY_UTYPE_POSITION_XYZ;
		Network::FixedMessages::MSGInfo* msgInfo =
			Network::FixedMessages::getSingleton().isFixed("Property::position");

		if (msgInfo != NULL)
			posuid = msgInfo->msgid;
	}

	PropertyDescription positionDescription(posuid, "VECTOR3", "position", ED_FLAG_ALL_CLIENTS, true, DataTypes::getDataType("VECTOR3"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && positionDescription.aliasID() == -1)
		positionDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_POSITION_XYZ);

	ENTITY_PROPERTY_UID diruid = 0;
	if (diruid == 0)
	{
		diruid = ENTITY_BASE_PROPERTY_UTYPE_DIRECTION_ROLL_PITCH_YAW;
		Network::FixedMessages::MSGInfo* msgInfo = Network::FixedMessages::getSingleton().isFixed("Property::direction");
		if (msgInfo != NULL)
			diruid = msgInfo->msgid;
	}

	PropertyDescription directionDescription(diruid, "VECTOR3", "direction", ED_FLAG_ALL_CLIENTS, true, DataTypes::getDataType("VECTOR3"), false, "", 0, "", DETAIL_LEVEL_FAR);
	if (pEntityScriptDefModule->usePropertyDescrAlias() && directionDescription.aliasID() == -1)
		directionDescription.aliasID(ENTITY_BASE_PROPERTY_ALIASID_DIRECTION_ROLL_PITCH_YAW);

	sourcefileBody_ += fmt::format("\n\t\tpublic override void onUpdatePropertys(Property prop, MemoryStream stream)\n\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\tswitch(prop.properUtype)\n\t\t\t{{\n");

	ScriptDefModule::PROPERTYDESCRIPTION_MAP clientPropertys = pEntityScriptDefModule->getClientPropertyDescriptions();
	clientPropertys[positionDescription.getName()] = &positionDescription;
	clientPropertys[directionDescription.getName()] = &directionDescription;

	ScriptDefModule::PROPERTYDESCRIPTION_MAP::const_iterator propIter = clientPropertys.begin();
	for (; propIter != clientPropertys.end(); ++propIter)
	{
		PropertyDescription* pPropertyDescription = propIter->second;

		std::string typestr;

		if (std::string("position") == pPropertyDescription->getName() ||
			std::string("direction") == pPropertyDescription->getName())
		{
#ifdef CLIENT_NO_FLOAT
			typestr = "Vector3Int";
#else
			typestr = "Vector3";
#endif
		}
		else
		{
			std::string findstr = fmt::format(" {} = ", pPropertyDescription->getName());
			std::string::size_type fpos2 = sourcefileBody_.find(findstr);
			std::string::size_type fpos1 = sourcefileBody_.rfind(" ", fpos2 - 1);
			typestr.assign(sourcefileBody_.begin() + fpos1 + 1, sourcefileBody_.begin() + fpos2);
		}

		sourcefileBody_ += fmt::format("\t\t\t\tcase {}:\n", pPropertyDescription->getUType());
		sourcefileBody_ += fmt::format("\t\t\t\t\t{} oldval_{} = {};\n", typestr, pPropertyDescription->getName(), pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\t{} = ({})prop.utype.createFromStream(stream);\n", pPropertyDescription->getName(), typestr);

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\t\t\t\t\tif(prop.isBase())\n\t\t\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\tif(inited)\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\ton{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\t}}\n\t\t\t\t\telse\n\t\t\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\tif(inWorld)\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\t\t\ton{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\t}}\n\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	}

	sourcefileBody_ += fmt::format("\t\t\t\tdefault:\n");
	sourcefileBody_ += fmt::format("\t\t\t\t\tbreak;\n");
	sourcefileBody_ += fmt::format("\t\t\t}};\n");
	sourcefileBody_ += "\t\t}\n";

	// 处理属性callPropertysSetMethods
	sourcefileBody_ += fmt::format("\n\t\tpublic override void callPropertysSetMethods()\n\t\t{{\n");
	sourcefileBody_ += fmt::format("\t\t\tScriptModule sm = EntityDef.moduledefs[className];\n");
	sourcefileBody_ += fmt::format("\t\t\tDictionary<UInt16, Property> pdatas = sm.idpropertys;\n\n");
	
	propIter = clientPropertys.begin();
	for (; propIter != clientPropertys.end(); ++propIter)
	{
		PropertyDescription* pPropertyDescription = propIter->second;

		std::string typestr;

		if (std::string("position") == pPropertyDescription->getName() ||
			std::string("direction") == pPropertyDescription->getName())
		{
#ifdef CLIENT_NO_FLOAT
			typestr = "Vector3Int";
#else
			typestr = "Vector3";
#endif
		}
		else
		{
			std::string findstr = fmt::format(" {} = ", pPropertyDescription->getName());
			std::string::size_type fpos2 = sourcefileBody_.find(findstr);
			std::string::size_type fpos1 = sourcefileBody_.rfind(" ", fpos2 - 1);
			typestr.assign(sourcefileBody_.begin() + fpos1 + 1, sourcefileBody_.begin() + fpos2);
		}

		sourcefileBody_ += fmt::format("\t\t\t{} oldval_{} = {};\n", typestr, pPropertyDescription->getName(), pPropertyDescription->getName());

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\t\t\tProperty prop_{} = pdatas[{}];\n", pPropertyDescription->getName(), pPropertyDescription->getUType());
		sourcefileBody_ += fmt::format("\t\t\tif(prop_{}.isBase())\n\t\t\t{{\n", pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\tif(inited && !inWorld)\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\ton{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t}}\n\t\t\telse\n\t\t\t{{\n");
		sourcefileBody_ += fmt::format("\t\t\t\tif(inWorld)\n");
		sourcefileBody_ += fmt::format("\t\t\t\t\tif(!prop_{}.isOwnerOnly() && isPlayer())\n", pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t\t\t\ton{}Changed(oldval_{});\n", name, pPropertyDescription->getName());
		sourcefileBody_ += fmt::format("\t\t\t}}\n\n");
	}

	sourcefileBody_ += "\t\t}\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic SByte {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(SByte oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int16 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Int16 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int32 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Int32 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int64 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Int64 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Byte {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Byte oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt16 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(UInt16 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt32 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(UInt32 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt64 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(UInt64 oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_FLOAT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic float {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0f"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(float oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_DOUBLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic double {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0d"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(double oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_STRING(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "\"\""));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(string oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UNICODE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "\"\""));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(string oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PYTHON(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PYTHON(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PY_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PY_DICT(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PY_TUPLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PY_TUPLE(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PY_LIST(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PY_LIST(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_BLOB(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new byte[0]"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(byte[] oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_ARRAY(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	if (std::string("ARRAY") == pPropertyDescription->getDataTypeName())
	{
		std::string s = sourcefileBody_;
		sourcefileBody_ = "";

		bool ret = writeTypeItemType_ARRAY(pPropertyDescription->getName(), pPropertyDescription->getDataType()->aliasName(), pPropertyDescription->getDataType());
		std::vector<std::string> values;
		values = KBEngine::strutil::kbe_splits(sourcefileBody_, " ");
		sourcefileBody_ = s + sourcefileBody_;

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed({} oldValue) {{}}\n", name, values[1]);
		return ret;
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", pPropertyDescription->getDataTypeName(), pPropertyDescription->getName(),
			pPropertyDescription->getDataTypeName());

		std::string name = pPropertyDescription->getName();
		name[0] = std::toupper(name[0]);
		sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed({} oldValue) {{}}\n", name, pPropertyDescription->getDataTypeName());
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_FIXED_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", pPropertyDescription->getDataTypeName(), pPropertyDescription->getName(),
		pPropertyDescription->getDataTypeName());

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed({} oldValue) {{}}\n", name, pPropertyDescription->getDataTypeName());
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_VECTOR2(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2Int(0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector2Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector2 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2(0f, 0f)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector2 oldValue) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_VECTOR3(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3Int(0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector3Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector3 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3(0f, 0f, 0f)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector3 oldValue) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_VECTOR4(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4Int(0, 0, 0, 0)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector4Int oldValue) {{}}\n", name);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector4 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4(0f, 0f, 0f, 0f)"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(Vector4 oldValue) {{}}\n", name);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_MAILBOX(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new byte[0]"));

	std::string name = pPropertyDescription->getName();
	name[0] = std::toupper(name[0]);
	sourcefileBody_ += fmt::format("\t\tpublic virtual void on{}Changed(byte[] oldValue) {{}}\n", name);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityMethod(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, MethodDescription* pMethodDescription, const char* fillString)
{
	sourcefileBody_ += fmt::format("\t\tpublic abstract void {}({}); \n", pMethodDescription->getName(), fillString);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityMethodArgs_ARRAY(FixedArrayType* pFixedArrayType, std::string& stackArgsTypeBody, const std::string& childItemName)
{
	std::string new_childItemName = childItemName;

	if (pFixedArrayType->type() == DATA_TYPE_FIXEDARRAY)
	{
		// 如果元素又是数组
		if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			FixedArrayType* pChildFixedArrayType = static_cast<FixedArrayType*>(pFixedArrayType->getDataType());

			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pFixedArrayType->aliasName(), fmt::format("List<{}>", pChildFixedArrayType->aliasName()));
			else
				new_childItemName = fmt::format("List<{}>", pChildFixedArrayType->aliasName());

			return writeEntityMethodArgs_ARRAY(pChildFixedArrayType, stackArgsTypeBody, new_childItemName);
		}
		else if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pFixedArrayType->aliasName(), pFixedArrayType->getDataType()->aliasName());
			else
				new_childItemName = pFixedArrayType->getDataType()->aliasName();
		}
		else
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pFixedArrayType->aliasName(), typeToType(pFixedArrayType->getDataType()->getName()));
			else
				new_childItemName = typeToType(pFixedArrayType->getDataType()->getName());
		}
	}

	stackArgsTypeBody += fmt::format("List<{}>", new_childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityMethodArgs_Const_Ref(DataType* pDataType, std::string& stackArgsTypeBody)
{
	return true;
}


//-------------------------------------------------------------------------------------
}
