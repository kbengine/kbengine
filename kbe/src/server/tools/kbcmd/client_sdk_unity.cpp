/*
This source file is part of KBEngine
For the latest info, see http://www.kbengine.org/

Copyright (c) 2008-2017 KBEngine.

KBEngine is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

KBEngine is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
 
You should have received a copy of the GNU Lesser General Public License
along with KBEngine.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "kbcmd.h"
#include "client_sdk.h"
#include "client_sdk_unity.h"	
#include "entitydef/entitydef.h"
#include "entitydef/scriptdef_module.h"
#include "entitydef/property.h"
#include "entitydef/method.h"
#include "entitydef/datatype.h"

namespace KBEngine {	

static std::string headerBody = "/*\n\tGenerated by KBEngine!\n\tPlease do not modify this file!\n#REPLACE#\ttools = kbcmd\n*/\n\n";
static std::string moduleSuffix = "Base";

//-------------------------------------------------------------------------------------
ClientSDKUnity::ClientSDKUnity():
	ClientSDK()
{
}

//-------------------------------------------------------------------------------------
ClientSDKUnity::~ClientSDKUnity()
{

}

//-------------------------------------------------------------------------------------
std::string ClientSDKUnity::typeToType(const std::string& type)
{
	if (type == "INT8")
	{
		return "SByte";
	}
	else if (type == "INT16")
	{
		return "Int16";
	}
	else if (type == "INT32")
	{
		return "Int32";
	}
	else if (type == "INT64")
	{
		return "Int64";
	}
	else if (type == "UINT8")
	{
		return "Byte";
	}
	else if (type == "UINT16")
	{
		return "UInt16";
	}
	else if (type == "UINT32")
	{
		return "UInt32";
	}
	else if (type == "UINT64")
	{
		return "UInt64";
	}
	else if (type == "FLOAT")
	{
		return "float";
	}
	else if (type == "DOUBLE")
	{
		return "double";
	}
	else if (type == "STRING")
	{
		return "string";
	}
	else if (type == "UNICODE")
	{
		return "string";
	}
	else if (type == "PYTHON")
	{
		return type;
	}
	else if (type == "PY_DICT")
	{
		return type;
	}
	else if (type == "PY_TUPLE")
	{
		return type;
	}
	else if (type == "PY_LIST")
	{
		return type;
	}
	else if (type == "BLOB")
	{
		return "byte[]";
	}
	else if (type == "ARRAY")
	{
		return "List";
	}
	else if (type == "FIXED_DICT")
	{
		return "Dictionary";
	}
#ifdef CLIENT_NO_FLOAT
	else if (type == "VECTOR2")
	{
		return "Vector2Int";
	}
	else if (type == "VECTOR3")
	{
		return "Vector3Int";
	}
	else if (type == "VECTOR4")
	{
		return "Vector4Int";
	}
#else
	else if (type == "VECTOR2")
	{
		return "Vector2";
	}
	else if (type == "VECTOR3")
	{
		return "Vector3";
	}
	else if (type == "VECTOR4")
	{
		return "Vector4";
	}
#endif
	else if (type == "MAILBOX")
	{
		return "byte[]";
	}

	return type;
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateTypeFileName()
{
	sourcefileName_ = "KBETypes.cs";
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateEntityModuleFileName(const std::string& moduleName)
{
	sourcefileName_ = moduleName + moduleSuffix + ".cs";
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateServerErrorDescrsModuleFileName()
{
	sourcefileName_ = "ServerErrorDescrs.cs";
}

//-------------------------------------------------------------------------------------
void ClientSDKUnity::onCreateEngineMessagesModuleFileName()
{
	sourcefileName_ = "Messages.cs";
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeServerErrorDescrsModuleBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += fmt::format("\tpublic struct {}\n\t{{\n\t\tpublic string name;\n\t\tpublic string descr;\n\t\tpublic UInt16 id;\n", "ServerErr");
	sourcefileBody_ += "\t}";

	sourcefileBody_ += "\n\n\t// defined in */res/server/server_errors.xml\n\n";
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", "ServerErrorDescrs");
	sourcefileBody_ += "\t\tpublic static Dictionary<UInt16, ServerErr> serverErrs = new Dictionary<UInt16, ServerErr>();\n\n";

	sourcefileBody_ += "\t\tpublic ServerErrorDescrs()\n\t\t{\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeServerErrorDescrsModuleErrDescr(int errorID, const std::string& errname, const std::string& errdescr)
{
	sourcefileBody_ += fmt::format("\t\t\t{{\n\t\t\t\tServerErr e;\n\t\t\t\te.id = {};\n\t\t\t\te.name = \"{}\";\n\t\t\t\te.descr = \"{}\";\n\n\t\t\t\tserverErrs.Add(e.id, e);\n", errorID, errname, errdescr);
	sourcefileBody_ += "\t\t\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeServerErrorDescrsModuleEnd()
{
	sourcefileBody_ += "\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic void Clear()\n\t\t{\n\t\t\tserverErrs.Clear();\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic string serverErrStr(UInt16 id)\n\t\t{\n\t\t\tServerErr e;\n\t\t\tif(!serverErrs.TryGetValue(id, out e))\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\treturn e.name + \"[\" + e.descr + \"]\";\n\t\t}\n\n";
	sourcefileBody_ += "\t\tpublic ServerErr serverErr(UInt16 id)\n\t\t{\n\t\t\tServerErr e;\n\t\t\tserverErrs.TryGetValue(id, out e);\n\t\t\treturn e;\n\t\t}\n\n";

	sourcefileBody_ += "\n\n\n\t}\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEngineMessagesModuleBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += "\tusing MessageID = System.UInt16;\n\n";

	sourcefileBody_ += "\n\n\t// engine messages\n\n";
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", "Message");

	sourcefileBody_ += "\t\tpublic MessageID id = 0;\n";
	sourcefileBody_ += "\t\tpublic string name;\n";
	sourcefileBody_ += "\t\tpublic Int16 msglen = -1;\n";
	sourcefileBody_ += "\t\tpublic KBEDATATYPE_BASE[] argtypes = null;\n";
	sourcefileBody_ += "\t\tpublic sbyte argsType = 0;\n";

	sourcefileBody_ += "\n\t\tpublic Messages(MessageID msgid, string msgname, Int16 length, sbyte argstype, List<Byte> msgargtypes)\n\t\t{\n";
	sourcefileBody_ += "\t\t\tid = msgid;\n";
	sourcefileBody_ += "\t\t\tname = msgname;\n";
	sourcefileBody_ += "\t\t\tmsglen = length;\n";
	sourcefileBody_ += "\t\t\targsType = argstype;\n\n";

	sourcefileBody_ += "\t\t\targtypes = new KBEDATATYPE_BASE[msgargtypes.Count];\n";
	sourcefileBody_ += "\t\t\tfor(int i=0; i<msgargtypes.Count; i++)\n";
	sourcefileBody_ += "\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\tif(!EntityDef.id2datatypes.TryGetValue(msgargtypes[i], out argtypes[i]))\n";
	sourcefileBody_ += "\t\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\t\tDbg.ERROR_MSG(\"Message::Message() : argtype(\" + msgargtypes[i] + \") is not found!\");\n";
	sourcefileBody_ += "\t\t\t\t}\n";
	sourcefileBody_ += "\t\t\t}\n\n";

	sourcefileBody_ += "\t\t\t// Dbg.DEBUG_MSG(string.Format(\"Message::Message() : ({ 0 } / {1} / {2})!\", \n";
	sourcefileBody_ += "\t\t\t//\t\tmsgname, msgid, msglen));";

	sourcefileBody_ += "\n\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic virtual object[] createFromStream(MemoryStream msgstream)\n";
	sourcefileBody_ += "\t\t{\n";
	sourcefileBody_ += "\t\t\tif(argtypes.Length <= 0)\n";
	sourcefileBody_ += "\t\t\t\treturn new object[]{msgstream};\n\n";
	sourcefileBody_ += "\t\t\tobject[] result = new object[argtypes.Length];\n\n";
	sourcefileBody_ += "\t\t\tfor(int i=0; i<argtypes.Length; i++);\n";
	sourcefileBody_ += "\t\t\t{\n";
	sourcefileBody_ += "\t\t\t\tresult[i] = argtypes[i].createFromStream(msgstream);\n";
	sourcefileBody_ += "\t\t\t}\n\n";
	sourcefileBody_ += "\t\t\treturn result;\n";
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\t\tpublic virtual void handleMessage(MemoryStream msgstream)\n";
	sourcefileBody_ += "\t\t{\n";
	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEngineMessagesModuleMessage(Network::ExposedMessageInfo& messageInfos, COMPONENT_TYPE componentType)
{
	sourcefileBody_ += fmt::format("\tpublic class Message_{} : Message\n\t{{\n", messageInfos.name);

	sourcefileBody_ += "\t\tpublic override void handleMessage(MemoryStream msgstream)\n";
	sourcefileBody_ += "\t\t{\n";

	if (messageInfos.argsTypes.size() == 0)
	{
		if (messageInfos.argsType < 0)
		{
			sourcefileBody_ += fmt::format("\t\t\tKBEngineApp.app.{}(msgstream);\n", messageInfos.name);
		}
		else
		{
			sourcefileBody_ += fmt::format("\t\t\tKBEngineApp.app.{}();\n", messageInfos.name);
		}
	}
	else
	{
		std::string argsparse = "";
		std::string giveargs = "";

		for (int i = 0; i < messageInfos.argsTypes.size(); ++i)
		{
			int argindex = (i + 1);
			argsparse += fmt::format("\t\t\tobject arg{} = argtypes[{}].createFromStream(msgstream);\n", argindex, i);
			giveargs += fmt::format("arg{}, ", argindex);
		}

		if (giveargs.size() > 0)
			giveargs.erase(giveargs.size() - 2, 2);

		sourcefileBody_ += argsparse;
		sourcefileBody_ += fmt::format("\t\t\tKBEngineApp.app.{}({});\n", messageInfos.name, giveargs);
	}

	sourcefileBody_ += "\t\t}\n\n";

	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEngineMessagesModuleEnd()
{
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypesBegin()
{
	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", "");

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += "\n\n\t// defined in */scripts/entity_defs/types.xml\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypesEnd()
{
	sourcefileBody_ += "\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeBegin(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += fmt::format("\tpublic class {}\n\t{{\n", typeName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeEnd(std::string typeName, FixedDictType* pDataType)
{
	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeBegin(std::string typeName, FixedArrayType* pDataType, const std::string& parentClass)
{
	sourcefileBody_ += fmt::format("\tpublic class {}{}\n\t{{\n", typeName, (parentClass.size() > 0 ? std::string(" : ") + parentClass : ""));
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeEnd(std::string typeName, FixedArrayType* pDataType)
{
	sourcefileBody_ += "\n\t}\n\n";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic SByte {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int16 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int32 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_INT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int64 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT8(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic Byte {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT16(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt16 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT32(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt32 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UINT64(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt64 {} = 0;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_FLOAT(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic float {} = 0f;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_DOUBLE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic double {} = 0d;\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_STRING(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_UNICODE(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = \"\";\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PYTHON(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PYTHON(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PY_DICT(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PY_DICT(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PY_TUPLE(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PY_TUPLE(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_PY_LIST(const std::string& itemName, const std::string& childItemName)
{
	ERROR_MSG("ClientSDKUnity::writeTypeItemType_PY_LIST(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_BLOB(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = new byte[0];\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_ARRAY(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	std::string new_childItemName = childItemName;

	if (pDataType->type() == DATA_TYPE_FIXEDARRAY)
	{
		FixedArrayType* pFixedArrayType = static_cast<FixedArrayType*>(pDataType);

		// 如果元素又是数组
		if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pDataType->aliasName(), fmt::format("List<{}>", pFixedArrayType->getDataType()->aliasName()));
			else
				new_childItemName = fmt::format("List<{}>", pFixedArrayType->getDataType()->aliasName());

			return writeTypeItemType_ARRAY(itemName, new_childItemName, pFixedArrayType->getDataType());
		}
		else if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pDataType->aliasName(), pFixedArrayType->getDataType()->aliasName());
			else
				new_childItemName = pFixedArrayType->getDataType()->aliasName();
		}
		else
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pDataType->aliasName(), typeToType(pFixedArrayType->getDataType()->getName()));
			else
				new_childItemName = typeToType(pFixedArrayType->getDataType()->getName());
		}
	}

	sourcefileBody_ += fmt::format("\t\tpublic List<{}> {} = new List<{}>();\n", new_childItemName, itemName, new_childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_FIXED_DICT(const std::string& itemName, const std::string& childItemName, DataType* pDataType)
{
	sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", childItemName, itemName, childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_VECTOR2(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = new Vector2Int(0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector2 {} = new Vector2(0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_VECTOR3(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = new Vector3Int(0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector3 {} = new Vector2(0f, 0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_VECTOR4(const std::string& itemName, const std::string& childItemName)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = new Vector4Int(0, 0, 0, 0);\n", itemName);
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector4 {} = new Vector4(0f, 0f, 0f, 0f);\n", itemName);
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeTypeItemType_MAILBOX(const std::string& itemName, const std::string& childItemName)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = new byte[0];\n", itemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityModuleBegin(ScriptDefModule* pEntityScriptDefModule)
{
	std::string newModuleName = fmt::format("{}{}", pEntityScriptDefModule->getName(), moduleSuffix);

	sourcefileBody_ = headerBody;
	strutil::kbe_replace(sourcefileBody_, "#REPLACE#", fmt::format("\tPlease inherit this module, such as: (class {} : {}{})\n",
		pEntityScriptDefModule->getName(), pEntityScriptDefModule->getName(), moduleSuffix));

	sourcefileBody_ += "namespace KBEngine\n{\n";
	sourcefileBody_ += "\tusing UnityEngine;\n";
	sourcefileBody_ += "\tusing System;\n";
	sourcefileBody_ += "\tusing System.Collections;\n";
	sourcefileBody_ += "\tusing System.Collections.Generic;\n\n";

	sourcefileBody_ += std::string("\t// defined in */scripts/entity_defs/") + pEntityScriptDefModule->getName() + ".def\n";

	sourcefileBody_ += fmt::format("\tpublic abstract class {} : if_Entity_error_use______git_submodule_update_____kbengine_plugins_______open_this_file_and_I_will_tell_you\n\t{{\n", newModuleName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityModuleEnd(ScriptDefModule* pEntityScriptDefModule)
{
	sourcefileBody_ += "\t}\n}";
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic SByte {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int16 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int32 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_INT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Int64 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT8(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic Byte {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT16(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt16 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT32(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt32 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UINT64(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic UInt64 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_FLOAT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic float {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0f"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_DOUBLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic double {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "0d"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_STRING(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "\"\""));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_UNICODE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic string {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "\"\""));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PYTHON(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PYTHON(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PY_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PY_DICT(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PY_TUPLE(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PY_TUPLE(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_PY_LIST(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	ERROR_MSG("ClientSDKUnity::writeEntityProperty_PY_LIST(): nonsupport!\n");
	return false;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_BLOB(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new byte[0]"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_ARRAY(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	if (std::string("ARRAY") == pPropertyDescription->getDataTypeName())
	{
		return writeTypeItemType_ARRAY(pPropertyDescription->getName(), pPropertyDescription->getDataType()->aliasName(), pPropertyDescription->getDataType());
	}
	else
	{
		sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", pPropertyDescription->getDataTypeName(), pPropertyDescription->getName(),
			pPropertyDescription->getDataTypeName());
	}

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_FIXED_DICT(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic {} {} = new {}();\n", pPropertyDescription->getDataTypeName(), pPropertyDescription->getName(),
		pPropertyDescription->getDataTypeName());

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_VECTOR2(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector2Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2Int(0, 0)"));
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector2 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector2(0f, 0f)"));
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_VECTOR3(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector3Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3Int(0, 0, 0)"));
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector3 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector3(0f, 0f, 0f)"));
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_VECTOR4(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
#ifdef CLIENT_NO_FLOAT
	sourcefileBody_ += fmt::format("\t\tpublic Vector4Int {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4Int(0, 0, 0, 0)"));
#else
	sourcefileBody_ += fmt::format("\t\tpublic Vector4 {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new Vector4(0f, 0f, 0f, 0f)"));
#endif

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityProperty_MAILBOX(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, PropertyDescription* pPropertyDescription)
{
	sourcefileBody_ += fmt::format("\t\tpublic byte[] {} = {};\n", pPropertyDescription->getName(),
		(strlen(pPropertyDescription->getDefaultValStr()) > 0 ? pPropertyDescription->getDefaultValStr() : "new byte[0]"));

	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityMethod(ScriptDefModule* pEntityScriptDefModule,
	ScriptDefModule* pCurrScriptDefModule, MethodDescription* pMethodDescription, const char* fillString)
{
	sourcefileBody_ += fmt::format("\t\tpublic abstract void {}({}); \n", pMethodDescription->getName(), fillString);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityMethodArgs_ARRAY(FixedArrayType* pFixedArrayType, std::string& stackArgsTypeBody, const std::string& childItemName)
{
	std::string new_childItemName = childItemName;

	if (pFixedArrayType->type() == DATA_TYPE_FIXEDARRAY)
	{
		// 如果元素又是数组
		if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDARRAY)
		{
			FixedArrayType* pChildFixedArrayType = static_cast<FixedArrayType*>(pFixedArrayType->getDataType());

			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pFixedArrayType->aliasName(), fmt::format("List<{}>", pChildFixedArrayType->aliasName()));
			else
				new_childItemName = fmt::format("List<{}>", pChildFixedArrayType->aliasName());

			return writeEntityMethodArgs_ARRAY(pChildFixedArrayType, stackArgsTypeBody, new_childItemName);
		}
		else if (pFixedArrayType->getDataType()->type() == DATA_TYPE_FIXEDDICT)
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pFixedArrayType->aliasName(), pFixedArrayType->getDataType()->aliasName());
			else
				new_childItemName = pFixedArrayType->getDataType()->aliasName();
		}
		else
		{
			if (new_childItemName.size() > 0)
				strutil::kbe_replace(new_childItemName, pFixedArrayType->aliasName(), typeToType(pFixedArrayType->getDataType()->getName()));
			else
				new_childItemName = typeToType(pFixedArrayType->getDataType()->getName());
		}
	}

	stackArgsTypeBody += fmt::format("List<{}>", new_childItemName);
	return true;
}

//-------------------------------------------------------------------------------------
bool ClientSDKUnity::writeEntityMethodArgs_Const_Ref(DataType* pDataType, std::string& stackArgsTypeBody)
{
	return true;
}


//-------------------------------------------------------------------------------------
}
